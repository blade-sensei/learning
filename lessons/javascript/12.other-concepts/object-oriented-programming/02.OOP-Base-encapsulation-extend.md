Pour rappel ce que la programmation objet ressout comme problème c'est:

- la fragilité: une modification qui casse trop facilement le code
- la ridigité: une nouvelle fonctionnalité qui va demander trop de changements un peu partout
- la non réusabilité: le code qui dépend trop d'autres modules et qui possède un fort couplage à une certaines dépendance par example, ne peux pas être réutilisé

En résumé, tout ces problèmes découlent du fait que si on crée un fort et trop de dépendance alors le code devient difficile à maintenir et faire évoluer.

C'est là que la programmation orienté objet peut résoudre ces problèmes, même s'il faut pas se tromper, une mauvaises utilisation de la POO peut aussi créer un code difficil à maintenir.

## Principes

il existe plusieurs principes qui font qu'on écris du code "orienté objet" mais pour le moment on va voir les plus importants:

### ENCAPSULATION

Ce principe repose sur l'exposition de méthodes qui intéressent seulement le client, les détails techniques, les attributs sont souvent inconnus du client de classe.

#### Avantages:

- ce principe résout le problème de "fragilité" et "réusabilité", en créant des "boites noirs" cet à dire en exposant seulement des "contrats" et des fonctionnalités (nécessaires) au publique
- Imaginons qu'on crée une class "ATM", dans une version simple il propose uniquement 2 fonctions, "déposer" et "retirer", pour pouvoir le programmer le technicien à besoin de paramétrer des devises, un montant maximal pour le retrait, un numéro d'identifiant de machine etc etc, mais l'utilisateur de ce CODE n'a pas besoin de connaitre tout ça, ce qui fait que si le technicien change un calcul ou la valeur maximal pour mettre à jour une conversion, cela diminue l'impacte dans d'autres parties de l'application.

## Example

```typescript

class ATM {
  identiant: StringFormatA;
  //autre attributs
  constructor(devise, identifiant) {
    //...
  }
  deposer(argent: Argent) {};
  retirer() { }: argent

  _verifierSiUserPossedeAssezDargent() {}
}

//le technicien configure
const atm = new ATM("EU", "AZE");

//Fichier Client.ts
atm.retirer();
atm.deposer(100);
```

- si on laisse Client.ts manipuler à sa guise la class ATM, alors à chaque petit changement sur ATM, on produira un changement qui va casser le code sur Client.ts mais imaginez que d'autres classes aussi manipulent ATM car elle veulent juste utilise l'identifiant ou utilise la fonction "verifierSiUserPossedeAssezDargent".. Fecilications le code est devenu fragile.
- c'est pour cela que l'encapsulation permet de réduire cette fragilité et permet aussi d'étendre notre notre plus facilement

## HERITAGE

L'héritage est le mécanisme de partage de comportement ou caractéristiques à travers un lien hiérarchique (un parent / enfants)

#### Avantages:

- La réutilisation de attributs et méthodes se fait plus simplement
- Un des principaux avantages de l'héritage c'est qu'on ajout un autre niveau d'abstraction, car on utilisera plutot la classe de base pour interagir avec le code des sous classes.

## Example

```ts
class Vehicule {
  //id
  //vitesse
  livrer() {}
}

class Camion extends Vehicule {
  //capacitéMax = 10
  constructor() {
    super();
  }
  livrer() {}
}

//Velo.js
class Velo extends Vehicule {
  //capacitéMax = 2
  constructor() {
    super();
  }
  livrer() {}
}

const flotte = [new Camion(), new Vehicule()];
//for each
flote.livrer();
```

## POLYMORPHISME

Ce principe un principe qui simplifie le mécanisme de substitution.
Par example on peut dire que un "Leopard" et un "Elephant" sont tous les deux des animaux
alors il peuvent être remplacés par un "Animal" class, pour éviter les dépendances.

Par extension, si un Leopard peut être remplacé par un "Animal", c'est que "Leopard" comporte toutes les caractéristiques et incluant les "actions/méthodes" d'un animal. De même pour Elephant. Pour une action `.courir()` les deux animaux ne vont pas courir à la même vitesse, mais n'empêche que tous les deux peuvent "courir"..

Ce principe est un peu complexe à comprendre au début, mais nous allons voir des examples pour démontrer que ce mécanisme est utile afin de ne pas créer du code rigide et fragile, avec plein de dépendances..

- Il existe plusieurs façon de créer un code "polymorphique" c'est à un code qui va pouvoir prendre plusieurs formes (en respectant les caractéristiques de base)
  - les interfaces (implementation)
  - classes abstraites (extension)

## Exercices

### 1.

## Références

- about OOP: https://camilomatajira.wordpress.com/2020/10/17/clean-architecture-by-bob-martin/
