
## INTRO

Les probl√®mes que l'on retrouve dans un logiciel peuvent √™tre :

- la fragilit√© : une modification qui casse trop facilement le code
- la rigidit√© : une nouvelle fonctionnalit√© qui va demander trop de changements un peu partout
- la non r√©utilisabilit√© du code (car trop de d√©pendances par exemple)

üîë En r√©sum√©, tous ces probl√®mes d√©coulent du fait que si l'on cr√©e un fort couplage et/ou trop de d√©pendances, alors le code devient difficile √† maintenir et √† faire √©voluer.

C'est l√† que la programmation orient√©e objet peut r√©soudre ces probl√®mes. Mais attention, une mauvaise utilisation de la POO peut aussi cr√©er un code difficile √† maintenir.

## 3 PRINCIPES

Il existe plusieurs principes qui font que l'on √©crit du code "orient√© objet", mais pour le moment, nous allons voir les plus importants :

- encapsulation
- h√©ritage
- polymorphisme
### ENCAPSULATION

- Ce principe repose sur l'exposition de m√©thodes qui int√©ressent seulement le client.
- Les d√©tails techniques vont √™tre **masqu√©s** par example: les attributs de la classe, la fa√ßon dont on calcul ou on affiche une valeur etc.
- MOT üîë -> **MASQUER** 

![[encapsulation-in-java 1.png]]


### Example

- Imaginons que l'on cr√©e une classe "ATM". Dans une version simple, elle propose uniquement deux fonctions : "d√©poser" et "retirer".
- Le retrait devrait normalement v√©rifier si l'on peut retirer le montant que le client souhaite. Par exemple, s'il n'y a pas assez d'argent dans une machine, il faut limiter le montant √† 1000 euros.
- Pour pouvoir le programmer, le technicien a besoin de param√©trer un montant maximal pour le retrait, un num√©ro d'identifiant de machine, etc. Cependant, l'utilisateur de la machine n'a pas besoin de conna√Ætre tout cela.
- Sauf que chaque agence de la banque a voulu avoir acc√®s √† ce param√®tre "montant max" pour pouvoir faire la v√©rification avant le retrait, et le faire selon ses propres r√®gles.
- La banque a d√©tect√© que l'agence B ne fait pas certaines v√©rifications... probl√®me.
- De plus, la banque d√©cide qu'un ATM peut d√©sormais donner 4000 euros. Le technicien doit donc changer le montant max dans chaque agence et r√©gler le probl√®me des v√©rifications.
- Mais si les "d√©tails" d'un retrait (v√©rifications) et le montant maximal n'avaient pas √©t√© entre les mains des agences, alors le technicien aurait pu juste modifier, sur son ordinateur, √† un seul endroit, le montant maximal. De m√™me pour la v√©rification du retrait, si c'√©tait interne √† la machine, alors il n'y aurait plus eu aucun probl√®me de modification.

```bash
- ATM -> votre code / classe
- le technicien -> VOUS, (le codeur)
- la banque -> votre PO, manager, chef de projet
- les agences -> l'endroit qui va utiliser votre code de retrait d'argent
```


```typescript

class ATM {
  identiant: StringFormatA;
  //autre attributs
  constructor(devise, identifiant) {
    //...
  }
  deposer(argent: Argent) {
    if (this.__verifierSiUserPossedeAssezDargent()) { 
      //...
    } 
  };
  retirer() { }: argent

  //cette m√©thode n'a pas besoin d'√™tre connu par celui qui veut faire un retrait
  //elle est donc masqu√©
  _verifierSiUserPossedeAssezDargent() {}
}

//le technicien configure
const atm = new ATM("EU", "AZE");

//Fichier Client.ts
//le client ne sait pas comment la machine r√©cup√®re l'argent, et c'est mieux
const argent = atm.retirer();
```

### Conclusion

- L'encapsulation permet de r√©duire cette fragilit√© et permet aussi d'√©tendre le code plus facilement
- En cr√©ant des  "boites noires" ‚¨õÔ∏è cet √† dire en exposant seulement des fonctionnalit√©s (n√©cessaires) que le client de ce code √† besoin et rien d'autre

## HERITAGE

- L'h√©ritage est le m√©canisme de **partage** de comportements ou de caract√©ristiques √† travers un lien hi√©rarchique (un parent / des enfants). Celui qui va partager est appel√© le parent, celui qui va recevoir cet h√©ritage (les attributs ou m√©thodes) est appel√© l'enfant.
- Ce m√©canisme de hi√©rarchie fait qu'√† la fois on "partage" mais aussi on "s√©pare" ce qui est sp√©cifique entre le parent et ses descendants.
- MOT üîë : PARTAGE ET S√âPARATION

## Example

![[0_5bscj-Hxw0AKkrzj 1.png]]


```ts


//CLASSE PARENT
class Vehicule {
  //id
  //vitesse
  rouler() {}
}

//CLASSE FILLE/ENFANT
class Camion extends Vehicule {
  //capacit√©Max = 10
  constructor() {
    super();
  }
  rouler() {}
}

//CLASSE FILLE/ENFANT
//Velo.js
class Velo extends Vehicule {
  //capacit√©Max = 2
  constructor() {
    super();
  }
  livrer() {}
}

const vehicules = [new Camion(), new Vehicule()];
//for each
vahicule.rouler();
```

## Example

- Que se passerait si on avait pas de Class pour chaque type de v√©hicule, on aurait peut √™tre 
	- soit plusieurs fonctions "roulerVoiture" "roulerCamion" 
	- soit une fonction "rouler(monVehicule)" qui prendrait le v√©hicule et selon le v√©hicule devrait soit le faire rouler + vite, soit lentement etc...
- Ces 2 fa√ßon se faire on des probl√®mes, l'un va dupliquer du code, agrandir les d√©pendances, cr√©er plusieurs points de bugs potentiels
- La 2eme fa√ßon, va faire que l'ajout d'un v√©hicule ou changement de la logique "rouler" impacte TOUS les autres v√©hicules, encore une fois, source de bug potentielle, couplage.. 
- Pour r√©soudre tout cela, on s√©pare les comportements sp√©cifiques dans plusieurs classes, et gr√¢ce √† l'h√©ritage, on peut r√©utiliser le attributs et m√©thodes d'une classe de "base".

### Conclusion

- La r√©utilisation de attributs et m√©thodes se fait plus simplement
- On s√©parer les comportements pour r√©duire le code "rigide/fragile"
- L'extension de notre code devient plus simple, on commence √† respecter le principe de "OPEN/CLOSE" (SOLID)
- Un des principaux avantages de l'h√©ritage c'est qu'on ajoute un autre niveau d'abstraction,  si on souhaite (souvent c'est le cas) on utilisera plut√¥t la classe de base pour ne pas se pr√©occuper des d√©tails (les classes enfant) 


## POLYMORPHISME

Ce m√©canisme permet √† un objet_x de type "TYPE_F" d'√™tre trait√© comme s'il √©tait un autre type d'objet, disons "TYPE_P". Bien s√ªr, pour √™tre trait√© comme un TYPE_P, l'objet_x doit pouvoir se comporter comme un "TYPE_P". Il doit avoir les m√™mes actions disponibles et attributs que ceux du TYPE_P.

```bash
TYPE_P -> Classe Parent
TYPE_F -> Classe Fille
```


Dans les langages "rigides"  (c'est mon terme, mais je veux dire fortement typ√©s), on a besoin de r√©duire le couplage et utiliser du code "g√©n√©rique"  pour avoir + de modularit√©.

### Example

Si j'ai un oiseau sp√©cifique, disons un "Aigle", l√† un zoo accepte des "Oiseaux", l'aigle peut rentrer ce zoo, car l'aigle poss√®de les caract√©ristiques d'un "Oiseau".

- Si un zoo, pr√©sente un spectacle d'oiseaux,
- je veux faire voler les aigles et les faucons, 
- on embauche quelqu'un qui sait faire voler les oiseaux mais il nous dit qu'il sait faire voler que les faucons et des aigles, au d√©but tout se passe bien, puis le zoo d√©cide que durant l'ann√©e ils int√©greront d'autres oiseaux
- on voudrait "g√©n√©raliser" sa comp√©tence pour faire voler les oiseaux, donc on va engager quelqu'un qui, peu importe le type d'oiseau, il pourra le faire voler, tant que c'est un "oiseau" qui sort de la niche, par avance le maitre du spectacle ne sait pas quel oiseau sort de la niche.
- le ma√Ætre (des oiseaux) va juste dire "VOL", peut importe le oiseau qui se trouve dans la cabane/niche.. l'action de "vol" sera remplac√© par le "vol sp√©cifique du oiseau qui vient de sortir"
- un aigle sort ? il est trait√© comme un oiseau, il peut voler ? ok, le vol que le publique verra sera un vol d'aigle, un faucon sort ?, il est trait√© comme un oiseau, donc l'action de voler aussi est "remplac√©" par le "vol" du faucon en question...
- C'est le POLYMORPHISME, pour le maitre le faucon, l'aigle ou la chouette, peuvent remplacer un "oiseau".
- Ok, au passage, on a un "petit" avantage d'avoir un spectacle "g√©n√©rique", semaine prochaine, le zoo, peut rajouter des Condors, le maitre sera capable de faire voler l'oiseau sans rien changer dans ses comp√©tences

```bash
Le ZOO -> votre application
Le Spectacle -> une fonctionnalit√©
Le maitre -> un module/un service
Le oiseau -> la classe parent
```

### Conclusion

- Ce principe un principe qui simplifie le m√©canisme de substitution
- Permet la mise en place d'un code plus g√©n√©rique et donc modulaire
- L'extension est plus simple √† faire (comme l'h√©ritage)

## Exercices



## R√©f√©rences


- good video: https://www.youtube.com/watch?v=SiBw7os-_zI
- about OOP: https://camilomatajira.wordpress.com/2020/10/17/clean-architecture-by-bob-martin/
- History: https://medium.com/javascript-scene/the-forgotten-history-of-oop-88d71b9b2d9f
- Video uncle bob: https://www.youtube.com/watch?v=zHiWqnTWsn4&t=3622s
