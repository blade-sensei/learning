
# C'est quoi 

C'est tout un systÃ¨me (ou un ensemble d'outils) qui nous permet d'avoir un **historique** de tout ce qui se passe dans notre projet.
- un ajout de code ? 
- une modification
- une installation
- etc
Tout ce qui se passe dans le projet sera "sauvegardÃ©" et on gardera une "trace" / "historique".

# Pourquoi

Nous avons prÃ©sentÃ© Git comme un outil de "sauvegarde et historique", mais la force de Git rÃ©side surtout dans ses fonctionnalitÃ©s qui nous permettent de :
- travailler avec plusieurs dÃ©veloppeurs.
En nous aidant Ã  mieux intÃ©grer, combiner et synchroniser le travail de chaque membre participant au dÃ©veloppement, ces membres peuvent travailler de faÃ§on isolÃ©e sans problÃ¨me (en gÃ©nÃ©ral). Chacun peut travailler sur sa tÃ¢che sans se faire de souci.
# Principes

avant d'aller plus loin dans la pratique 
- commit
- staging
- head
- branches
## commit
C'est un "point" dans notre historique, un instant T qui dÃ©termine une version de notre projet. 
On peut dire que notre historique c'est une sorte de "cahier/journal" pour sauvegarder des modifications ou des ajouts de notre projet.

Lorsqu'on crÃ©e un commit, c'est comme Ã©crire dans ce petit cahier, certaines informations du nouveau "point" de l'historique.

Par exemple, le commit aura un titre pour expliquer le but des ajouts ou modifications, la date de la "sauvegarde", l'auteur (quel dÃ©veloppeur a fait le commit), un identifiant, etc.

**Important** ğŸ”‘ : Vous devez comprendre que ce "cahier" ou "journal" oÃ¹ nous sauvegardons l'historique du projet se trouve UNIQUEMENT dans votre ordinateur. Prenez en compte cette information qui nous servira plus loin pour expliquer le concept de "remote".
## staging
avant de sauvegarder avec un "commit", on doit dÃ©clarer nos "modifications/ajouts" comme "prÃªtes Ã  Ãªtre sauvegardÃ©s"

cette zone ou on garde "temporairement" les **changements prÃªts** s'appelle le "staging"

Git nous donne cette feature afin d'avoir une Ã©tape "intermÃ©diaire" pour pouvoir 
sauvegarder notre travail en diffÃ©rents "fragments"..

Si je travail sur une fonctionnalitÃ© de login et que aujourd'hui j'ai dÃ©veloppÃ© le formulaire mais il me manque encore la gestion des erreurs, alors je peux choisir de  sauvegarder le fichier "Formulaire.js" en attendant de terminer la gestion d'erreurs.. 

Voici un graphique pour visualiser:

![[Pasted image 20240605155123.png]]

## head

Le head c'est un le "point" de sauvegarde oÃ¹ vous vous trouvez actuellement dans votre projet. 
Par example, si dans votre "cahier d'historique" vous avez crÃ©e un **"point" X**  hier, pour la fonctionnalitÃ© de login. Aujourd'hui si vous avez crÃ©e un autre **"point" Z**, 

votre "head" actuel est le point Z, mais si vous voulez revenir au point X, alors votre "head" deviendra le point X.

Vous avez compris donc, head c'est juste un "nom" qui dÃ©finit le "oÃ¹ je suis actuellement", une sorte de "post it".
## branches

Pour expliquer ce concept, prenons un cas rÃ©elle de ce qui peux arriver dans un projet.

Recap: jusqu'Ã  maintenant, vous avez travaillÃ© tout seul et sur votre ordinateur, et vous avez crÃ©e petit Ã  petit un **historique VERT**  ğŸŸ¢, avec des fonctionnalitÃ©s etc.. vous allez toujours travailler sur votre ordinateur, mais cette fois, votre manager vous demande de travailler sur 2 fonctionnalitÃ©s. "Feature 1"  et "Feature 2".


Dans l'image ci-dessous, il faut lire l'historique de gauche Ã  droite... pour l'ordre chronologique, donc imaginez que actuellement vous avez seulement plusieurs commits verts et le DERNIER c'est celui de "gauche"

![[1_vOgcWxc9PW10b-E6VndtLQ.png]]

- **sÃ©curiser notre code qui fonctionne** 
	- pour ne pas prendre le risque d'abimer l'historique vert, vous voulez garder une version "stable", de votre projet, c'est Ã  dire une version qui fonctionne, sans problÃ¨mes/bugs, Ã§a sera votre **historique vert** ğŸŸ¢
	- vous crÃ©ez une **copie de TOUT l'historique** ğŸ”‘, dans votre copie, le dernier commit est le point vert.

- **feature 1**
	- Aujourd'hui vous travaillez sur la feature 1, vous faites 1 premier point (commit), ce commit correspond au point "violet" ğŸŸ£
	- Demain votre manager vous demande de travailler sur la feature 2 car elle doit Ãªtre prÃ©sentÃ© au client
	-  Vous ne pouvez pas âŒ  dÃ©marrer votre travail Ã  partir du point violet, puisque c'est une feature qui n'est pas terminÃ©, vous devez partir du point **stable**

- **feature 2**
	- vous allez donc crÃ©er une autre **copie de l'historique** ğŸ”‘ (Ã  partir du point stable) afin de prÃ©parer la feature 2 
	- vous ajoutez quelques fichiers et vous crÃ©e un **commit** pour crÃ©er un point "bleu" ğŸ”µ
	- vous estimez que la fonctionnalitÃ© "feature 2 ğŸ”µ" est prÃªte, alors vous  **fusionnez** votre copie avec **l'historique stable** ğŸŸ¢ (cela crÃ©e un commit VERT)
	
- **retour sur feature 1**
	- vous pouvez continuer Ã  travailler tranquillement sur feature 1 dans votre **COPIE d'historique**, vous ajoutez un dernier commit ğŸŸ£
- **fusionner** 
	- pour terminer, vous "fusionner" votre copie violette avec l'historique stable (vert), qui lui avait dÃ©jÃ  eu la feature 2 dans son historique, cela crÃ©e un "commit vert" ğŸŸ¢
	- maintenant l'historique stable comporte les fichier de la feature 2 et de la feature 1.

## Conclusion

- une BRANCHE = correspond Ã  chaque "copie de l'historique d'origine" ğŸ”‘ dans notre example ci-dessus.
- GrÃ¢ce au systÃ¨me de branches, nous avons pu sÃ©curiser le code "stable", et on a pu travailler de faÃ§on indÃ©pendante, sur 2 fonctionnalitÃ©s diffÃ©rentes.
- Chaque branche Ã  un nom, par example la branche stable s'appelle souvent "master"

## local et remote

Pour le moment, vous savez que vous pouvez utiliser git, pour vous seulement, sans forcement travailler Ã  plusieurs, vous savez aussi que l'historique est gardÃ© sur votre ordinateur uniquement, tout cet historique, ces  commits etc, c'est votre **repository LOCAL**, 
local car tout est sur votre ordinateur

maintenant si on veut intÃ©grer un membre Ã  notre projet ? on lui demander d'avancer sur la page de "connection" par example.

Notre nouveau collÃ¨gue, travail depuis chez lui sur son ordinateur.. donc on va devoir "partager" notre "repository" n'est pas ? on peut pas lui donner la version de notre "cahier d'historique" car tout est dans notre ordinateur..  alors comment faire ?

on va copier/envoyer notre "cahier d'historique" sur un serveur disponible sur "internet/web",  ainsi il pourra rÃ©cupÃ©rer une "copie" du "cahier d'historique" juste en se connectant Ã  une adresse internet..

cette **COPIE** du cahier d'historique QUI EST sur "internet" c'est le "repository REMOTE" (remote = loin)

###  Visuellement

- grÃ¢ce Ã  ce repository (depot) "REMOTE", le dÃ©veloppeur Ã  distance peut rÃ©cupÃ©rer et synchroniser son travail.
- souvent ce systÃ¨me de repository remote vient en PLUS une interface WEB pour gÃ©rer ce repository.. par example
- examples d'outils pour hÃ©berger son repository sur internet: Github, Bitbucket, Gitlab, AzureRepo...

![[Pasted image 20240605153451.png]]

# RÃ©fÃ©rences

- bon article: https://www.atlassian.com/fr/git/tutorials/what-is-git
- Git tips & notes: https://duzun.me/tips/git
- 


